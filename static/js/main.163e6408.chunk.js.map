{"version":3,"sources":["Components/Node/Node.js","Algorithms/AStar/AStar.js","Algorithms/Djikstra/Djikstra.js","Components/PathFind/PathFind.js","App.js","index.js"],"names":["Node","props","row","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","classes","className","id","sortNodesByFscore","nextToVisit","sort","nodeA","nodeB","fVal","heuristic","x1","y1","x2","y2","Math","sqrt","pow","addNeighbours","grid","dijkstra","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","Infinity","isVisited","previousNode","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","updateUnvisitedNeighbors","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","rows","PathFind","useState","Grid","setGrid","mouseIsPressed","setMouseIsPressed","isStartSelected","setIsStartSelected","isFinishSelected","setIsFinishSelected","NODE_START_ROW","set_NODE_START_ROW","NODE_START_COL","set_NODE_START_COL","NODE_FINISH_ROW","set_NODE_FINISH_ROW","cols","NODE_FINISH_COL","set_NODE_FINISH_COL","useEffect","initializeGrid","Array","i","createSpot","j","Spot","this","neighbours","gridWithNode","map","rowIdx","colIdx","newGrid","getNewGridWithWallToggled","handleMouseDown","changeStartNode","changeFinishNode","handleMouseEnter","slice","animateVisitedNodes","nodesInShortestPathOrder","setTimeout","animateShortestPath","document","getElementById","visualizeAstar","clearPath","currentNode","neighbour","includes","astar","unshift","getAstarNodesInShortestPathOrder","classList","remove","add","onClick","getNodesInShortestPathOrder","visualizeDijkstra","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.163e6408.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./Node.css\";\r\n\r\nconst Node = (props) => {\r\n  const {\r\n    row,\r\n    col,\r\n    isFinish,\r\n    isStart,\r\n    isWall,\r\n    onMouseDown,\r\n    onMouseEnter,\r\n    onMouseUp,\r\n  } = props;\r\n  const classes = isStart\r\n    ? \"start-node\"\r\n    : isFinish\r\n    ? \"end-node\"\r\n    : isWall\r\n    ? \"wall-node\"\r\n    : \"\";\r\n  return (\r\n    <div\r\n      className={`node ${classes}`}\r\n      id={`node-${row}-${col}`}\r\n      onMouseDown={() => onMouseDown(row, col)}\r\n      onMouseEnter={() => onMouseEnter(row, col)}\r\n      onMouseUp={() => onMouseUp()}\r\n    ></div>\r\n  );\r\n};\r\n\r\nexport default Node;\r\n","export const astar = (grid, startNode, finishNode) => {\r\n  addNeighbours(grid);\r\n  const nextToVisit = [];\r\n  const visitedNodesInOrder = [];\r\n  nextToVisit.push(startNode);\r\n\r\n  while (nextToVisit.length > 0) {\r\n    sortNodesByFscore(nextToVisit);\r\n    const currentNode = nextToVisit.shift();\r\n\r\n    if (currentNode.isWall) continue;\r\n\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    currentNode.isVisited = true;\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    const neighbours = currentNode.neighbours;\r\n\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      let neighbour = neighbours[i];\r\n      if (!visitedNodesInOrder.includes(neighbour)) {\r\n        neighbour.fVal = heuristic(neighbour, finishNode);\r\n        neighbour.previousNode = currentNode;\r\n        nextToVisit.push(neighbour);\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n};\r\n\r\nconst sortNodesByFscore = (nextToVisit) => {\r\n  nextToVisit.sort((nodeA, nodeB) => nodeA.fVal - nodeB.fVal);\r\n};\r\n\r\nconst heuristic = (nodeA, nodeB) => {\r\n  const x1 = nodeA.row;\r\n  const y1 = nodeA.col;\r\n  const x2 = nodeB.row;\r\n  const y2 = nodeB.col;\r\n\r\n  const d = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\r\n  return d;\r\n};\r\n\r\nexport function getAstarNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\nconst addNeighbours = (grid) => {\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      node.addNeighbours(grid);\r\n    }\r\n  }\r\n};\r\n","export function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid, startNode);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n\r\n    if (closestNode.isWall) continue;\r\n\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid, startNode) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      if (node !== startNode) {\r\n        node.distance = Infinity;\r\n      }\r\n      node.isVisited = false;\r\n      node.previousNode = null;\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import React, { useState, useEffect } from \"react\";\r\nimport Node from \"../Node/Node\";\r\n\r\nimport \"./PathFind.css\";\r\n\r\nimport {\r\n  astar,\r\n  getAstarNodesInShortestPathOrder,\r\n} from \"./../../Algorithms/AStar/AStar\";\r\nimport {\r\n  dijkstra,\r\n  getNodesInShortestPathOrder,\r\n} from \"./../../Algorithms/Djikstra/Djikstra\";\r\n\r\nconst cols = 55;\r\nconst rows = 23;\r\n\r\nconst PathFind = () => {\r\n  const [Grid, setGrid] = useState([]);\r\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\r\n  const [isStartSelected, setIsStartSelected] = useState(false);\r\n  const [isFinishSelected, setIsFinishSelected] = useState(false);\r\n  const [NODE_START_ROW, set_NODE_START_ROW] = useState(0);\r\n  const [NODE_START_COL, set_NODE_START_COL] = useState(0);\r\n  const [NODE_FINISH_ROW, set_NODE_FINISH_ROW] = useState(rows - 1);\r\n  const [NODE_FINISH_COL, set_NODE_FINISH_COL] = useState(cols - 1);\r\n\r\n  useEffect(() => {\r\n    initializeGrid();\r\n  }, []);\r\n\r\n  const initializeGrid = () => {\r\n    const grid = new Array(rows);\r\n\r\n    for (let i = 0; i < rows; i++) {\r\n      grid[i] = new Array(cols);\r\n    }\r\n\r\n    createSpot(grid);\r\n\r\n    setGrid(grid);\r\n  };\r\n\r\n  const createSpot = (grid) => {\r\n    for (let i = 0; i < rows; i++) {\r\n      for (let j = 0; j < cols; j++) {\r\n        grid[i][j] = new Spot(i, j);\r\n      }\r\n    }\r\n  };\r\n\r\n  // Spot Constructor\r\n  function Spot(i, j) {\r\n    this.row = i;\r\n    this.col = j;\r\n    this.isStart = this.row === NODE_START_ROW && this.col === NODE_START_COL;\r\n    this.isFinish =\r\n      this.row === NODE_FINISH_ROW && this.col === NODE_FINISH_COL;\r\n    this.distance = Infinity;\r\n    this.isVisited = false;\r\n    this.isWall = false;\r\n    this.previousNode = null;\r\n    this.fVal = 0;\r\n    this.neighbours = [];\r\n    this.addNeighbours = (grid) => {\r\n      let i = this.row;\r\n      let j = this.col;\r\n      if (i > 0) this.neighbours.push(grid[i - 1][j]);\r\n      if (i < rows - 1) this.neighbours.push(grid[i + 1][j]);\r\n      if (j > 0) this.neighbours.push(grid[i][j - 1]);\r\n      if (j < cols - 1) this.neighbours.push(grid[i][j + 1]);\r\n    };\r\n  }\r\n\r\n  const handleMouseDown = (row, col) => {\r\n    if (row === NODE_START_ROW && col === NODE_START_COL) {\r\n      setIsStartSelected(true);\r\n    } else if (row === NODE_FINISH_ROW && col === NODE_FINISH_COL) {\r\n      setIsFinishSelected(true);\r\n    } else {\r\n      const newGrid = getNewGridWithWallToggled(Grid, row, col);\r\n      setGrid(newGrid);\r\n    }\r\n\r\n    setMouseIsPressed(true);\r\n  };\r\n\r\n  const handleMouseEnter = (row, col) => {\r\n    if (!mouseIsPressed) return;\r\n    if (isStartSelected) {\r\n      changeStartNode(Grid, row, col);\r\n    } else if (isFinishSelected) {\r\n      changeFinishNode(Grid, row, col);\r\n    } else {\r\n      const newGrid = getNewGridWithWallToggled(Grid, row, col);\r\n      setGrid(newGrid);\r\n    }\r\n  };\r\n\r\n  const handleMouseUp = () => {\r\n    setMouseIsPressed(false);\r\n    setIsStartSelected(false);\r\n    setIsFinishSelected(false);\r\n  };\r\n\r\n  const gridWithNode = (\r\n    <div>\r\n      {Grid.map((row, rowIdx) => (\r\n        <div key={rowIdx} className=\"rowWrapper\">\r\n          {row.map((col, colIdx) => {\r\n            const { isStart, isFinish, isWall } = col;\r\n            return (\r\n              <Node\r\n                key={colIdx}\r\n                isStart={isStart}\r\n                isFinish={isFinish}\r\n                isWall={isWall}\r\n                row={rowIdx}\r\n                col={colIdx}\r\n                mouseIsPressed={mouseIsPressed}\r\n                onMouseDown={(row, col) => handleMouseDown(row, col)}\r\n                onMouseEnter={(row, col) => handleMouseEnter(row, col)}\r\n                onMouseUp={() => handleMouseUp()}\r\n              />\r\n            );\r\n          })}\r\n        </div>\r\n      ))}\r\n    </div>\r\n  );\r\n\r\n  const getNewGridWithWallToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    newGrid[row][col].isWall = !newGrid[row][col].isWall;\r\n    return newGrid;\r\n  };\r\n\r\n  const changeStartNode = (grid, row, col) => {\r\n    if (row === NODE_FINISH_ROW && col === NODE_FINISH_COL) return;\r\n    if (row === NODE_START_ROW && col === NODE_START_COL) return;\r\n    const newGrid = grid.slice();\r\n    newGrid[NODE_START_ROW][NODE_START_COL].isStart = false;\r\n    newGrid[NODE_START_ROW][NODE_START_COL].isWall = false;\r\n    newGrid[row][col].isWall = false;\r\n    newGrid[row][col].isStart = true;\r\n\r\n    set_NODE_START_ROW(row);\r\n    set_NODE_START_COL(col);\r\n\r\n    return newGrid;\r\n  };\r\n\r\n  const changeFinishNode = (grid, row, col) => {\r\n    if (row === NODE_FINISH_ROW && col === NODE_FINISH_COL) return;\r\n    if (row === NODE_START_ROW && col === NODE_START_COL) return;\r\n    const newGrid = grid.slice();\r\n    newGrid[NODE_FINISH_ROW][NODE_FINISH_COL].isWall = false;\r\n    newGrid[NODE_FINISH_ROW][NODE_FINISH_COL].isFinish = false;\r\n    newGrid[row][col].isWall = false;\r\n    newGrid[row][col].isFinish = true;\r\n\r\n    set_NODE_FINISH_ROW(row);\r\n    set_NODE_FINISH_COL(col);\r\n\r\n    return newGrid;\r\n  };\r\n\r\n  const animateVisitedNodes = (\r\n    visitedNodesInOrder,\r\n    nodesInShortestPathOrder\r\n  ) => {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          animateShortestPath(nodesInShortestPathOrder);\r\n        }, 5 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, 5 * i);\r\n    }\r\n  };\r\n\r\n  const animateShortestPath = (nodesInShortestPathOrder) => {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-shortest-path\";\r\n      }, 10 * i);\r\n    }\r\n  };\r\n\r\n  const visualizeDijkstra = () => {\r\n    clearPath();\r\n    const startNode = Grid[NODE_START_ROW][NODE_START_COL];\r\n    const finishNode = Grid[NODE_FINISH_ROW][NODE_FINISH_COL];\r\n    const visitedNodesInOrder = dijkstra(Grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    animateVisitedNodes(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  };\r\n\r\n  const visualizeAstar = () => {\r\n    clearPath();\r\n    const startNode = Grid[NODE_START_ROW][NODE_START_COL];\r\n    const finishNode = Grid[NODE_FINISH_ROW][NODE_FINISH_COL];\r\n    const visitedNodesInOrder = astar(Grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder =\r\n      getAstarNodesInShortestPathOrder(finishNode);\r\n    animateVisitedNodes(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  };\r\n\r\n  const clearPath = () => {\r\n    const newGrid = Grid.slice();\r\n    for (let i = 0; i < rows; ++i) {\r\n      for (let j = 0; j < cols; ++j) {\r\n        document\r\n          .getElementById(`node-${i}-${j}`)\r\n          .classList.remove(\"node-shortest-path\", \"node-visited\");\r\n\r\n        if (i === NODE_START_ROW && j === NODE_START_COL) {\r\n          document.getElementById(`node-${i}-${j}`).classList.add(\"start-node\");\r\n        }\r\n        if (i === NODE_FINISH_ROW && j === NODE_FINISH_COL) {\r\n          document.getElementById(`node-${i}-${j}`).classList.add(\"end-node\");\r\n        }\r\n\r\n        newGrid[i][j].isVisited = false;\r\n        newGrid[i][j].previousNode = null;\r\n        newGrid[i][j].neighbours = [];\r\n        newGrid[i][j].distance = Infinity;\r\n      }\r\n    }\r\n    setGrid(newGrid);\r\n  };\r\n\r\n  const clearBoard = () => {\r\n    clearPath();\r\n    initializeGrid();\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <nav className=\"navbar\">\r\n        <h1 className=\"nav-title\">Pathfinding Algorithm Visualizer</h1>\r\n        <div className=\"leftMargin\" />\r\n        <button className=\"nav-button\" onClick={() => visualizeDijkstra()}>\r\n          Visualize Dijkstra's Algorithm\r\n        </button>\r\n        <button className=\"nav-button\" onClick={() => visualizeAstar()}>\r\n          Visualize AStar Algorithm\r\n        </button>\r\n        <button className=\"nav-button\" onClick={() => clearPath()}>\r\n          Clear Path\r\n        </button>\r\n        <button className=\"nav-button\" onClick={() => clearBoard()}>\r\n          Clear Board\r\n        </button>\r\n      </nav>\r\n      <div className=\"wrapper\">\r\n        <ul className=\"notation\">\r\n          <li className=\"notation-element\">\r\n            <div className=\"static-node start-node\" />\r\n            Start Point\r\n          </li>\r\n          <li className=\"notation-element\">\r\n            <div className=\"static-node end-node\" />\r\n            End Point\r\n          </li>\r\n          <li className=\"notation-element\">\r\n            <div className=\"static-node wall-node\" />\r\n            Wall\r\n          </li>\r\n          <li className=\"notation-element\">\r\n            <div className=\"static-node node-visited-static\" />\r\n            Visited Nodes\r\n          </li>\r\n          <li className=\"notation-element\">\r\n            <div className=\"static-node node-shortest-path-static\" />\r\n            Final Path\r\n          </li>\r\n        </ul>\r\n        {gridWithNode}\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default PathFind;\r\n","import \"./App.css\";\nimport PathFind from \"./Components/PathFind/PathFind\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFind />\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}